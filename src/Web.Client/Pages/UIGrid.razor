@using System.Text.Json
@using Web.Client.Services
@using System.Net

@inject IHttpClientFactory HttpClientFactory;
@implements IKeyEventListener
@rendermode InteractiveWebAssembly

<div>
	<div class="d-flex justify-content-between">
        <h2>Snekpoeng: @_game.Score</h2>
		<div class="p-2">
            <label for="toggleMusic" class="fw-bold px-2">Music</label>
            <input id="toggleMusic" type="checkbox" @bind="_enableMusic"/>
		</div>
	</div>
	@if (_playMusic)
	{
		<audio id="musicPlayer" autoplay muted=@_playMusic><source src="assets/music.mp3" /></audio>
		<script>document.getElementById('musicPlayer').volume = 0.1</script>
	}

	<div style="background-color: black;">
		@for (int i = 0; i < _game.Grid.Length; i++)
		{
			<div class="snek-row">
				@for (int j = 0; j < _game.Grid[0].Length; j++)
				{
					<Cell
						Row="@i"
						Col="@j"
						Value="@_game.Grid[i][j]"
						SnekDirection="@_game.CurrentSnekDirection" />
				}
			</div>
		}
	</div>
	@if (_gameOver)
	{
		<div class="position-absolute top-50 start-50 translate-middle text-center">
			<h1 class="text-white">Game Over</h1>
			@if (_scoreResponseCode == HttpStatusCode.BadRequest)
			{
				<h3 class="text-white">Juks og fanteri!</h3>
				<h4 class="text-white">Spill spillet alene for å få highsnek på lista</h4>
			}
			<button class="btn btn-primary" @onclick="ResetGame">Reset</button>
		</div>
	}
</div>

@code {
	private Game _game;
	private PeriodicTimer _timer = new PeriodicTimer(TimeSpan.FromMilliseconds(75));
	private bool _gameOver = false;
	private bool _timerStarted = false;
	private bool _enableMusic = true;
	private bool _playMusic = false;
	private HttpStatusCode _scoreResponseCode; 

	protected override void OnInitialized()
    {
		_game = new Game(HttpClientFactory);	
    }

	private async Task InitTimer()
	{
		_playMusic = _enableMusic;
		while (await _timer.WaitForNextTickAsync())
		{
			bool validState = _game.Update();
			_gameOver = !validState;
			if (!validState)
			{
				_playMusic = false;
			}
			StateHasChanged();
			if (!validState)
			{
				_scoreResponseCode = await _game.GameOver();
				StateHasChanged();
				break;
			}
		}
	}

	protected override void OnAfterRender(bool firstRender)
	{
		if (firstRender)
		{
			KeyEventHandler.RegisterListener(this);
		}
	}

	private void ResetGame()
	{
		_gameOver = false;
		_timerStarted = false;
		_game.Init();
		StateHasChanged();
	}

	public async Task KeyEventChanged(string keys)
	{
		var keyList = JsonSerializer.Deserialize<List<string>>(keys);

		var requestedSnekDirection = _game.CurrentSnekDirection;
		var requestedFoodDirection = _game.CurrentFoodDirection;

		foreach (string key in keyList)
		{
			switch (key)
			{
				case "Enter":
					if (_gameOver)
					{
						ResetGame();
					}
					return;
				case "k":
				case "ArrowUp":
					requestedSnekDirection = Direction.Up;
					break;
				case "j":
				case "ArrowDown":
					requestedSnekDirection = Direction.Down;
					break;
				case "h":
				case "ArrowLeft":
					requestedSnekDirection = Direction.Left;
					break;
				case "l":
				case "ArrowRight":
					requestedSnekDirection = Direction.Right;
					break;
				case "w":
					requestedFoodDirection = Direction.Up;
					break;
				case "s":
					requestedFoodDirection = Direction.Down;
					break;
				case "a":
					requestedFoodDirection = Direction.Left;
					break;
				case "d":
					requestedFoodDirection = Direction.Right;
					break;
			}
		}

        _game.ChangeSnekDirection(requestedSnekDirection);
        _game.ChangeFoodDirection(requestedFoodDirection);

        if (!_gameOver && !_timerStarted)
        {
            await InitTimer();
            _timerStarted = true;
        }
	}
}
